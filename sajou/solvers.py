#!/usr/bin/env python
# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
import scipy.sparse as sparse
from sajou.postprocessing import Postprocess
from scipy.linalg import lu_factor, lu_solve
from scipy.sparse.linalg import dsolve


#import scipy as sp
""" This module contains the different solvers used by the program.
"""


class Solver(object):
    """Parent class for the solvers used"""

    def __init__(self, model, **kwargs):
        """Initialize solver

        :model: TODO
        :**kwargs: Additional options:

            - :output: list of keywords specifying the different results that need to be
              computed after the solution is found.
              Accepted values are:
                - 'reactions'
                - 'internal forces'
                - 'stresses'
                - 'strains'
                - 'energy'


        """
        self._model = model
        # The variable 'output' stores the different results that need
        # to be computed after the solution is found.
        # FIXME: implement this
        deffault_output = ['displacements', 'forces']
        self._output_request = kwargs.get('output', None)


class StaticSolver(Solver):
    """Linear Static solver used to solve the most typical problems"""

    def __init__(self, model, **kwargs):
        """Initialize the solver instance

        Optional parameters:
        nlg: boolean, consider geometrical nonlinearities (Default False)

        """
        Solver.__init__(self, model, **kwargs)

    def solve(self):
        """Solves the problem
        :returns: numpy array

        """
        # Assemble the stiffness matrix of the system
        K = self._model._assemble_global_K()
        # Assemble the vector of applied loads (FIXME)
        P = self._model._generate_loading_vector()
        # Assemble the vector of applied element loads
        P_e = self._model._generate_element_loading_vector()

        # Apply Dirichlet boundary conditions
        # Get the dof corresponding to Dirichlet border conditions
        V = self._model._generate_displacement_vector()
        dirich_ind = self._model._dof_dirichlet
        # Calculate forces generated by the BC
        P_dirich = K.todense()[dirich_ind, :] @ V
        # Create new loading vector, including the forces generated by
        # the Dirichlet BC and element forces:
        P_new = P[:]
        # - Dirichlet BC
        P_new[dirich_ind] = P[dirich_ind] - P_dirich
        # - Add the element loads to the global loading vector
        P_new += P_e

        # Generate the new augmented stiffness matrix
        # Takes into account the Dirichlet BC
        K_new = np.copy(K.todense())
        K_new[dirich_ind, :] = 0.
        K_new[:, dirich_ind] = 0.

        for index in dirich_ind:
            K_new[index, index] = 1.
            P_new[index] = V[index]

        # Convert to sparse matrix
        K_new = sparse.csr_matrix(K_new)

        # Solve the augmented system (nodal displacements are computed)
        V_res = dsolve.spsolve(K_new, P_new, use_umfpack=False)

        # Initialize a Result object
        # - Copy the data of the model
        model_data = self._model.export_model_data()
        # - Create Result object
        result = Result(model=model_data)

        # Add nodal displacements to the result object
        self.calc_nodal_displ(result, V_res, K, P_e)

        # Add nodal reactions to the results object
        self.calc_nodal_reactions(result, V_res, K, P_e)

        # Add nodal forces to the result object
        self.calc_nodal_forces(result, V_res, K, P_e)

        # Add end forces to the results object
        self.calc_end_forces(result, V_res)

        # Postprocess the results according to the specified in 'output'
        # variable
        result = self.postprocess(result)

        return result

    def postprocess(self, result):
        """Postprocess the specified results given in the 'output' variable

        :result: TODO
        :returns: TODO

        """
        #
        postp = Postprocess(result)
        #
        for curr_output in self._output_request:
            if curr_output == 'internal forces':
                # Calculate forces along the frame elements
                postp.calc_all_internal_forces()
            elif curr_output == 'deflections':
                postp.calc_all_deflections()
            # FIXME: not sure if put this here
            elif curr_output == 'stresses':
                postp.calc_stresses(result)
            else:
                print('Post-processing of ' + curr_output +
                      ' not implemented yet.')

        return result

    def calc_nodal_displ(self, result, nodal_displ, K, elem_load):
        """Calculate the nodal displacements

        Parameters
        ----------

        result: Results object
            result obtained from the Solver
        nodal_displ: ndarray
            displacements array calculated after the solve process
        K: ndarray
            Stiffness matrix
        elem_load: ndarray
            Elemetn load

        """
        # generate a list of the nodes of the system
        nodes = [n for i, n in self._model.nodes.items()]
        # get the node freedom map table of the model
        nfmt = self._model.nfmt
        # get the node freedom allocation table
        nfat = self._model.nfat

        # initialize empty dictionary
        dict_displ = dict()

        # Loop for each node of the model
        for node_i in nodes:
            # the the index of the node
            ix_node = node_i.number
            # get the indices for the node's DOFs on the global system
            ix_i = nfmt[ix_node]
            ix_f = ix_i + sum(node_i.nfs)
            # get the displacements for the specified node
            dict_displ[ix_node] = nodal_displ[ix_i: ix_f]

        result.add_result('nodal displacements', dict_displ)

        return dict_displ

    def calc_nodal_forces(self, result, nodal_displ, K, elem_load):
        """Compute the nodal forces

        Parameters
        ----------
        result: Result object
            result obtained from the solver
        nodal_displ: ndarray
            nodal displacements calculated with the stiffness matrix
        K: ndarray
            Stiffness matrix
        elem_load: TODO
        :returns: TODO

        """
        # calculate the nodal forces
        nodal_forces = K @ nodal_displ - elem_load

        # get the node freedom map table
        nfmt = self._model.nfmt
        nodes = self._model.nodes

        dict_nf = dict()
        # Loop for each node of the model
        for num, curr_node in nodes.items():
            # get total DOFs of the node
            ndof = curr_node.n_dof
            # get node number
            ix = curr_node.number
            # get node freedom signature
            nfs = curr_node.nfs
            # initialize nodal force vector
            nod_force = np.zeros(ndof)
            #
            indices = np.arange(ndof)[nfs>0]
            nod_force[indices] = nodal_forces[nfmt[ix]: nfmt[ix] + sum(nfs)]
            dict_nf[ix] = nod_force

        result.add_result('nodal forces', dict_nf)

        return dict_nf

    def calc_nodal_reactions(self, result, nodal_displ, K, elem_load):
        """Calculate the nodal reactions of the model.

        Parameters
        ----------

        result: Result object
            result obtained with Solver
        nodal_displ: ndarray
            nodal displacements
        K: ndarray
            stiffness matrix
        elem_forces: ndarray
            element forces vector

        Returns
        -------

        ndarray: nodal reactions

        """
        # Get the positions of the Dirichlet birder conditions
        dirich_ind = result._model._dof_dirichlet
        # (Take the element loads into account with 'P_e')
        nodal_react = (K @ nodal_displ)[dirich_ind] - elem_load[dirich_ind]
        # Add result to the Result object
        result.add_result('nodal reactions', nodal_react)

        # Make dictionary with nodes and respective node reactions
        for ix, index_r in enumerate(dirich_ind):
            node_i, dof_i = self._model.get_node_and_dof(index_r)
            # Add the reactions to the dictionary of reactions of the
            # corresponding node
            node_i.reactions[dof_i] = nodal_react[ix]

        return nodal_react

    def calc_end_forces(self, result, nodal_displ):
        """
        Calculate the internal forces of elements.

        Parameters
        ----------

        result: Result object
            used to store the results to
        nodal_displ: ndarray
            nodal displacements obtained from the solver

        Returns
        -------

        dict: End forces

        """
        # Initialize dictionary with results of the end forces
        end_forces = dict()
        # Get the node freedom map table
        nfmt = self._model.nfmt
        # Get the node freedom allocation of every node
        nfat = self._model.nfat
        # Calculate end forces for each element
        for num, element in self._model.elements.items():
            # Get the transformation matrix for the element
            Te = element.transformation_matrix
            # Get the stiffness matrix of the element in global coordinates
            # FIXME!
            Ke = element._Ke
            # Get the displacements of the corresponding DOFs in global coordinates
            # - Initialize matrix
            v_i = np.zeros(element._k_size, dtype=np.float64)
            P_e_i = np.zeros(element._k_size, dtype=np.float64)
            # Get the node freedom allocation map table of the current element
            enfmt = element.enfmt
            # Initiate element load vector
            # Assemble matrix with element nodal displacements of the current
            # element
            for n_node_e, node in element._nodal_connectivity.items():
                # Indices for the array v_i
                index_base = element.get_element_active_dof(n_node_e)
                i_index = index_base + enfmt[n_node_e]
                # Indices corresponding to the position of the DOF of
                # the current node analyzed (global system)
                index_base_n = element.get_node_active_dof(n_node_e)
                j_index = index_base_n + nfmt[node.number]
                # Add the results for these DOFs to the v_i array
                v_i[i_index] = nodal_displ[j_index]  # DOF of node selected
                # Account for element loads
                if len(element._loads) > 0:
                    # Same indices are used here
                    for load in element._loads:
                        P_e_i[i_index] += load._load_vector_global[i_index]

            # Get the End Forces of the element in global coordinates
            P_i_global = Ke @ v_i - P_e_i
            # Transform End Forces to local coordinates
            P_i_local = Te @ P_i_global
            # Add End Forces to the dictionary of End Forces of the result object
            # for the current element
            end_forces[element.number] = P_i_local
            # Add the corresponding nodal forces to the matrix to
            # calculate the sectional forces
            # - Axial force
            element._poly_sec_force[0, 0] += -P_i_local[0]
            # - Shear force
            element._poly_sec_force[0, 1] += P_i_local[1]
            # - Moment
            element._poly_sec_force[0, 2] += -P_i_local[2]
            element._poly_sec_force[1, 2] += P_i_local[1]

        # Add results to the result object
        result.add_result('end forces', end_forces)

        return end_forces


class Result(object):
    """An object to store the data obtained from the solving process"""

    def __init__(self, model):
        """TODO: to be defined1. """
        # Analyzed model
        self._model = model
        # Initiate the container for the results
        self.data = dict()
        # Initialize dictionary with information of minimum and maximum
        # values of the results, and other useful data.
        self.metadata = dict()

    def add_result(self, name, results):
        """Add results to the results dictionary

        :name: TODO
        :results: TODO
        :returns: TODO

        """
        self.data[name] = results

        return self

    def add_metadata(self, name, results):
        """Add results to the results dictionary

        :name: TODO
        :results: TODO
        :returns: TODO

        """
        self.metadata[name] = results

        return self
